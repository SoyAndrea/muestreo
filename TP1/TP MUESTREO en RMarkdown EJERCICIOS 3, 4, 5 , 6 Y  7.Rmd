---
title: "TP Muestreo"
output: html_document
date: "2024-11-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


############## !!! Aun tengo que pasar ejercicios 1 y 2 que hizo Lu. Pase el 3 (que hizo Lu) porque me sirve para ejercicios 4 y 5


# EJERCICIO 3


```{r LIBRERIAS}
#install.packages("readxl")
#install.packages("writexl")
#install.packages("ggplot2")
#install.packages("dplyr")
#install.packages("sampling")
#install.packages("survey")
library(readxl)
library(writexl)
library(ggplot2)
library(dplyr)
library(sampling)
library(survey)
```

```{r Armado de tablas}

# Lectura de las tablas
radios_sexo <- read_excel("cen2010_radios_sexo.xlsx")
radios_tipo <- read_excel("cen2010_radios_tipo.xlsx")

# Juntamos los archivos para unificarlos en un unico dataframe
radios_2010 = merge(radios_sexo, radios_tipo, by = "Codigo")


# Generamos nuevas variables en el dataframe que utilizaremos mas adelante
# Juntamos los archivos para unificarlos en un unico dataframe
radios_2010 = merge(radios_sexo, radios_tipo, by = "Codigo")

# Generamos nuevas variables en el dataframe que utilizaremos mas adelante

# Poblacion total en cada radio
radios_2010$Pob_radio <- radios_2010$Varon + radios_2010$Mujer 

# Cantidad de viviendas en cada radio
radios_2010$Viv_radio <-  radios_2010$Casa + 
  radios_2010$Rancho + 
  radios_2010$Casilla + 
  radios_2010$Departamento + 
  radios_2010$Inquilinato + 
  radios_2010$Hotel_pension

# Extraemos el codigo de provincia
radios_2010$prov <- floor(radios_2010$Codigo/10000000)


# Creamos etiqueta para las provincias
radios_2010$Provincia <- "X"
radios_2010 <- radios_2010 %>%
  mutate(Provincia = case_when(prov == 2 ~ 'CABA', prov == 6 ~ 'BsAs',
                               prov == 10 ~ 'Catamarca', prov == 14 ~ 'Cordoba',
                               prov == 18 ~ 'Corrientes', prov == 22 ~ 'Chaco',
                               prov == 26 ~ 'Chubut', prov == 30 ~ 'Entre Rios',
                               prov == 34 ~ 'Formosa', prov == 38 ~ 'Jujuy',
                               prov == 42 ~ 'La Pampa', prov == 46 ~ 'La Rioja',
                               prov == 50 ~ 'Mendoza', prov == 54 ~ 'Misiones',
                               prov == 58 ~ 'Neuquen', prov == 62 ~ 'Rio Negro',
                               prov == 66 ~ 'Salta', prov == 70 ~ 'San Juan',
                               prov == 74 ~ 'San Luis', prov == 78 ~ 'Santa Cruz',
                               prov == 82 ~ 'Santa Fe', prov == 86 ~ 'Santiago',
                               prov == 90 ~ 'Tucuman', prov == 94 ~ 'TdFuego'))

print(radios_2010)
```

```{r Armado de tablas I }
# Eliminamos los radios sin viviendas
radios_2010 <- radios_2010[radios_2010$Viv_radio>0,]
N=nrow(radios_2010)
n=240

print(radios_2010)
```

## 1. Buscamos hallar los cuatro parámetros o valores poblacionales

```{r Parámetros}

poblacion<- sum(radios_2010$Pob_radio)
hogares_casa<-sum(radios_2010$Casa)
hogares_rancho<-sum(radios_2010$Rancho)+sum(radios_2010$Casilla)
prop_rancho<-(sum(radios_2010$Rancho)+sum(radios_2010$Casilla))/sum(radios_2010$Viv_radio)

print(poblacion)
print(hogares_casa)
print(hogares_rancho)
print(prop_rancho)
```

## 2. Calculamos la varianza para la estimacion del total:

```{r CV}


# En el MAS 
# Var(y_media) = (1-n/N)*S^2/n  
# Var(N*y_media) = N^2*(1-n/N)*S^2/n
P=prop_rancho
Q=1-prop_rancho
P+Q

S2_pob <- var(radios_2010$Pob_radio)
S2_casa <- var(radios_2010$Casa)
S2_rancho <- var(radios_2010$Rancho + radios_2010$Casilla)
S2_prop <- P*Q

VarMAS_MediaPob <- (1-n/N)*S2_pob/n
VarMAS_MediaCasa <- (1-n/N)*S2_casa/n
VarMAS_MediaRancho <- (1-n/N)*S2_rancho/n


VarMAS_pob <- N^2*VarMAS_MediaPob   #Recordar: Var(k*X)= k^2*Var(X)
VarMAS_casa <- N^2*VarMAS_MediaCasa 
VarMAS_rancho <- N^2*VarMAS_MediaRancho 


# Calculamos el coeficiente de variacion
CVMAS_Pob <- 100*sqrt(VarMAS_pob)/poblacion
CVMAS_Casa <- 100*sqrt(VarMAS_casa)/hogares_casa
CVMAS_Rancho <- 100*sqrt(VarMAS_rancho)/hogares_rancho

ds_prop<-sqrt(P*Q)
CVMAS_Prop <- 100 *(ds_prop/prop_rancho) #revisar

CVMAS_Pob
CVMAS_Casa
CVMAS_Rancho
CVMAS_Prop #revisar

```

El CV de la estimación de rancho o casilla es grande porque el N del universo es menor que en el caso de la población general y los hogares tipo casa.
El CV de la proporción de rancho o casilla es grande porque el valor de P es muy pequeño

```{r CV II}

#n=240*43

#para que el cv de la estimación de la población sea aproximadamente 2% n debe ser 1000
#para que el cv de la estimación de hogares tipo rancho o casilla sea aproximadamente 2% n debe ser 10000
```


```{r Muestra aleatoria simple}


# Seleccionamos ahora una muestra aleatoria simple con R
s_mas <- sample(N,n, replace=FALSE)

muestra_radios <- radios_2010[s_mas,]

#estimaciones muestrales N*y_media

muestra_poblac<-N*mean(muestra_radios$Pob_radio)
muestra_casa<-N*mean(muestra_radios$Casa)
muestra_rancho<-N*mean(muestra_radios$Rancho+muestra_radios$Casilla)
muestra_prop<-(sum(muestra_radios$Rancho)+sum(muestra_radios$Casilla))/sum(muestra_radios$Viv_radio)

# Agregamos al data frame el factor de expansion
# (recordar que seleccione una muestra aleatoria simple de radios)
muestra_radios$pondera <- N/n


# Cantidad total de unidades en el marco de muestreo
# lo necesitare luego para survey
muestra_radios$fpc <- N  

#junto rancho y casilla
muestra_radios$rancho_casilla <- muestra_radios$Rancho + muestra_radios$Casilla

# El objeto 'diseno' contiene toda la informacion que sera empleada para realizar las estimaciones.


diseno <- svydesign(id= ~1,weights=~pondera, data=muestra_radios, fpc=~fpc)
diseno
# (como es una muestra aleatoria simple ponemos fpc)

# Por ejemplo, si queremos extraer los pesos de un diseno podemos utilizar
pesos <- weights(diseno)


# total población
EstTotalPob <- survey :: svytotal(~Pob_radio, diseno, deff=TRUE, cv=TRUE, ci=TRUE)
EstTotalPob

# Puedo ahora extraer diferentes valores:
survey :: cv(EstTotalPob)      # -> coeficiente de variacion
deff(EstTotalPob)    # -> efecto de diseno
SE(EstTotalPob)      # -> desvio estandar
confint(EstTotalPob) # -> intervalor de confianza (por defecto 95%)
cv(EstTotalPob)

# O pasar los resultados a un data frame
df_EstTotalPob <- as.data.frame(EstTotalPob)

# Quiero cambiar el nombre de las columnas
colnames(df_EstTotalPob) <- c("Estimacion", "SE", "deff")

```


# Calculemos ahora el intervalo de confianza con un 90% de confianza
# (suponemos que el estimador es aprox normal)

```{r Intervalos de confianza}
df_EstTotalPob$Li <- df_EstTotalPob$Estimacion-1.64*df_EstTotalPob$SE  
df_EstTotalPob$Ls <- df_EstTotalPob$Estimacion+1.64*df_EstTotalPob$SE  


# Ahora calculo el CV del estimador
df_EstTotalPob$CV <-  100*df_EstTotalPob$SE/df_EstTotalPob$Estimacion


# total casas
EstTotalcasa <- survey :: svytotal(~Casa, diseno, deff=TRUE, cv=TRUE, ci=TRUE)
EstTotalcasa

# Puedo ahora extraer diferentes valores:
survey :: cv(EstTotalcasa)      # -> coeficiente de variacion
deff(EstTotalcasa)    # -> efecto de diseno
SE(EstTotalcasa)      # -> desvio estandar
confint(EstTotalcasa) # -> intervalor de confianza (por defecto 95%)
cv(EstTotalcasa)

# O pasar los resultados a un data frame
df_EstTotalcasa <- as.data.frame(EstTotalcasa)

# Quiero cambiar el nombre de las columnas
colnames(df_EstTotalcasa) <- c("Estimacion", "SE", "deff")

# Calculemos ahora el intervalo de confianza con un 90% de confianza
# (suponemos que el estimador es aprox normal)
df_EstTotalcasa$Li <- df_EstTotalcasa$Estimacion-1.64*df_EstTotalPob$SE  
df_EstTotalcasa$Ls <- df_EstTotalcasa$Estimacion+1.64*df_EstTotalPob$SE  


# Ahora calculo el CV del estimador
df_EstTotalcasa$CV <-  100*df_EstTotalcasa$SE/df_EstTotalPob$Estimacion



# total rancho y casilla
EstTotalrancho <- survey :: svytotal(~rancho_casilla, diseno, deff=TRUE, cv=TRUE, ci=TRUE)
EstTotalrancho

# Puedo ahora extraer diferentes valores:
survey :: cv(EstTotalrancho)      # -> coeficiente de variacion
deff(EstTotalrancho)    # -> efecto de diseno
SE(EstTotalrancho)      # -> desvio estandar
confint(EstTotalrancho) # -> intervalor de confianza (por defecto 95%)
cv(EstTotalrancho)

# O pasar los resultados a un data frame
df_EstTotalrancho <- as.data.frame(EstTotalrancho)

# Quiero cambiar el nombre de las columnas
colnames(df_EstTotalrancho) <- c("Estimacion", "SE", "deff")

# Calculemos ahora el intervalo de confianza con un 90% de confianza
# (suponemos que el estimador es aprox normal)
df_EstTotalrancho$Li <- df_EstTotalrancho$Estimacion-1.64*df_EstTotalPob$SE  
df_EstTotalrancho$Ls <- df_EstTotalrancho$Estimacion+1.64*df_EstTotalPob$SE  


# Ahora calculo el CV del estimador
df_EstTotalrancho$CV <-  100*df_EstTotalrancho$SE/df_EstTotalrancho$Estimacion


# proporcion
Estproporcion <- survey::svyratio(~rancho_casilla,~Viv_radio,  design = diseno, deff = TRUE, cv = TRUE, ci = TRUE)

Estproporcion

# Puedo ahora extraer diferentes valores:
estimador <- coef(Estproporcion)  # Estimador de la proporción
error_estandar <- SE(Estproporcion)  # Error estándar
cv <- CV(Estproporcion)  # Coeficiente de variación
intervalo_confianza <- confint(Estproporcion)  # Intervalo de confianza

#IC 90%

IC90Li <- estimador-1.64*error_estandar
IC90Ls <- estimador+1.64*error_estandar


# Ahora calculo el CV del estimador
CV <-  100*error_estandar/estimador

```




# EJERCICIO 4 

## Estimación, encuestando en su totalidad una Muestra Sistemática de n=240 radios censales para Total de población, Total de hogares que habitan en viviendas tipo Casa y Total de hogares que habitan en viviendas rancho/ casilla

### Estimación para Población

```{r Armo Tabla E4}

#Creo una nueva tabla para este ejercicio con la base que ya armamos en el Ejercicio 3.

radios_2010E4 <- radios_2010

N <- nrow(radios_2010E4)

# Tamano de la muestra
n <- 240

# Intervalo de selección
I <- floor(N/n)
print(I)

# Parametro poblacional
ParametroPobE4 <- sum(radios_2010E4$Pob_radio)
print(ParametroPobE4)

# Ordenamiento del marco de muestreo
radios_2010E4 <- radios_2010E4[order(radios_2010E4$Codigo),]
radios_2010E4$aleatorio <- runif(nrow(radios_2010E4),0,1)
radios_2010E4 <- radios_2010E4[order(radios_2010E4$Viv_radio),]
radios_2010E4 <- radios_2010E4[order(radios_2010E4$Pob_radio),]
radios_2010E4 <- radios_2010E4[order(radios_2010E4$aleatorio),]

```


```{r Arranque aleatorio}

# Definiremos el arranque aleatorio, generando un número aleatorio entre 1 y el intervalo de selección I, que en nuestro caso es 218. 


#aa <- sample(1:I, 1)
aa = 75
print(aa)

#El resultado de aa es 75. Le pondremos un # a la función dado que cada vez que se ejecuta cambiará el valor de aa

```


```{r Seleccion sistemática}

#Seleccionaremos una muestra sistemática de los datos en radios_2010E4 utilizando el arranque aleatorio aa = 75


s = radios_2010E4[ seq(aa,N,I), ]

``` 


Calcularemos una estimación del total poblacional y su error relativo para evaluar la precisión de la muestra sistemática.


```{r Precisión}

#Primero realizaremos la estimación del total poblacional usando el método de Horvitz-Thompson, un estimador insesgado en muestreo sistemático.

estim <- I*sum(s$Pob_radio)
print(estim)

error_rel <- 100*(ParametroPobE4 - estim) /ParametroPobE4
print(error_rel)

```

La estimación de la población usando una muestra de 240 radios censales es muy cercana al parámetro poblacional ParametroPobE4 (40115211), lo cual sugiere que la muestra debería ser buena.El error relativo es muy bajo, por lo que la muestra puede proveer una estimación precisa.


### Estimación para viviendas tipo Casa

```{r Casa}

#Parámetro poblacional para viviendas tipo Casa:
ParametroCasaE4 <- sum(radios_2010E4$Casa)  
print(ParametroCasaE4)

#Estimación para la muestra:
estimCasaE4 <- I * sum(s$Casa)  
print(estimCasaE4)

#Error relativo
error_relCasaE4 <- 100 * (ParametroCasaE4 - estimCasaE4) / ParametroCasaE4
print(error_relCasaE4)

```

El valor de la estimación calculada a partir de la muestra se aproxima bastante al valor real de la población, por lo cual el muestreo es representativo y el tamaño de la muestra se puede interpretar como adecuado.
El error relativo es muy bajo, por lo que la estimación es bastante cercana al parámetro poblacional real.


### Estimación para viviendas tipo Rancho o Casilla


```{r RanchoCasilla}

# Crear la columna Rancho_Casilla
radios_2010E4$Rancho_Casilla <- radios_2010E4$Rancho + radios_2010E4$Casilla

# Seleccionar la muestra sistemática
s = radios_2010E4[seq(aa, N, I), ]

# Parámetro poblacional
ParametroRanchoCasillaE4 <- sum(radios_2010E4$Rancho_Casilla)
print(ParametroRanchoCasillaE4)

# Estimación para la muestra
estimRanchoCasillaE4 <- I * sum(s$Rancho_Casilla)
print(estimRanchoCasillaE4)

# Error relativo
error_relRanchoCasillaE4 <- 100 * (ParametroRanchoCasillaE4 - estimRanchoCasillaE4) / ParametroRanchoCasillaE4
print(error_relRanchoCasillaE4)

```


La estimación de 426408 es cercano al parametro 461725, lo cual indica que el muestreo sistemático es preciso para estimar el total de viviendas tipo rancho o casilla.El error relativo es muy bajo siendo un buen indicador de precisión en el muestreo


## Compararemos dos estrategias utilizando como estimador la media muestral

###1. Muestreo sistemático, ordenando la tabla por Provincia-Total de viviendas del radio

Primero indicamos aquí nuevamente los parámetros que obtuvimos en el punto anterior:

```{r parametros E4}

print(ParametroPobE4)
print(ParametroCasaE4)
print(ParametroRanchoCasillaE4)

```

Comenzamos con la estrategia 1 que implica Orden por "Provincia-Total de viviendas del radio"

```{r Estrategia1 E4}

# Ordenar por Provincia y Total de viviendas del radio
Estrategia1E4 <- radios_2010E4[order(radios_2010E4$Provincia, radios_2010E4$Viv_radio), ]

# Tamaño de la muestra y cálculo del intervalo
n <- 240
N <- nrow(Estrategia1E4)
I <- floor(N / n)
print(I)

# Arranque aleatorio
# aa <- sample(1:I, 1)
# La función arroja un aa de 191. Le colocamos # dado que sino arrojará un aa diferente en cada ejecución
aa = 191
print(aa)

# Selección sistemática
muestraE1 <- Estrategia1E4[seq(aa, N, by = I), ]

# Estimaciones para la muestra en Estrategia 1
estimPobE1 <- I * mean(muestraE1$Pob_radio)
estimCasaE1 <- I * mean(muestraE1$Casa)
estimRancho_CasillaE1 <- I * mean(muestraE1$Rancho + muestraE1$Casilla)

print(estimPobE1)
print(estimCasaE1)
print(estimRancho_CasillaE1)

```
Ahora revisamos el error relativo para Estrategia 1

```{r error relativo Estrategia1 E4}
error_relPobE1 <- 100 * abs(ParametroPobE4 - estimPobE1) / ParametroPobE4
error_relCasaE1 <- 100 * abs(ParametroCasaE4 - estimCasaE1) / ParametroCasaE4
error_relRancho_CasillaE1 <- 100 * abs(ParametroRanchoCasillaE4 - estimRancho_CasillaE1) / ParametroRanchoCasillaE4

print(error_relPobE1)
print(error_relCasaE1)
print(error_relRancho_CasillaE1)
```
Los errores relativos son muy altos (cercanos al 100%), lo que indica que la estimación está muy alejada del valor poblacional, pudiendo interpretar que el ordenamiento esté afectando la representatividad.


###2. Muestreo sistemático, ordenando la tabla por un número pseudo aleatorio

```{r Estrategia2 E4}

# Ordenar por el número aleatorio
Estrategia2E4 <- radios_2010E4 [order(radios_2010E4$aleatorio), ]

# Selección sistemática
muestraE2 <- Estrategia2E4 [seq(aa, N, by = I), ]

# Estimaciones para la muestra en Estrategia 2
estimPobE2 <- I * mean(muestraE2$Pob_radio)
estimCasaE2 <- I * mean(muestraE2$Casa)
estimRancho_CasillaE2 <- I * mean(muestraE2$Rancho + muestraE2$Casilla)

print(estimPobE2)
print(estimCasaE2)
print(estimRancho_CasillaE2)
```


```{r error relativo Estrategia2 E4}

error_relPobE2 <- 100 * abs(ParametroPobE4 - estimPobE2) / ParametroPobE4
error_relCasaE2 <- 100 * abs(ParametroCasaE4 - estimCasaE2) / ParametroCasaE4
error_relRancho_CasillaE2 <- 100 * abs(ParametroRanchoCasillaE4 - estimRancho_CasillaE2) / ParametroRanchoCasillaE4

print(error_relPobE2)
print(error_relCasaE2)
print(error_relRancho_CasillaE2)

```

Al parecer ninguna de las estrategias estaría dando resultados dado que los errores relativos son muy altos. La estrategia de muestreo sistemático puede que no sea la más adecuada para este caso.


## Hallar CV, deff, sesgo relativo y EMC de cada estrategia, seleccionando todas las muestas posibles

Para evaluar cada estrategia y medir su eficiencia y precisión, podemos calcular el coeficiente de variación (CV), el efecto del diseño (deff), el sesgo relativo y el error medio cuadrático (EMC). 

Para ello, calcularemos las I estimaciones posibles, una para cada arranque aleatorio. Definiremos una funcion que seleccione una muestra sistematica, con el arranque aleatorio como variable independiente y devuelva la estimacion

Primero, definimos las funciones para seleccionar la muestra sistemática y para calcular los estimadores necesarios para todas las posibles muestras.

### Estrategia 1

```{r funciones Estrategia 1}

# Tamaño de la población y de la muestra
N <- nrow(Estrategia1E4)  # total de radios censales
n <- 240                   # tamaño de la muestra
I <- floor(N / n)          # intervalo de selección

# Valor verdadero del parámetro poblacional 
parametro_poblacionalEst1 <- sum(Estrategia1E4$Pob_radio)

# Definimos la función de estimación sistemática
estim_sistematico <- function(aa) {
  s = Estrategia1E4[seq(aa, N, I), ]
  estim <- I * sum(s$Pob_radio)
  return(c(estim))
}

estimacionEst1 <- estim_sistematico(2)

print(parametro_poblacionalEst1)
print(estimacionEst1)

```



```{r estimaciones posibles estrategia 1}

# Calculamos las I estimaciones posibles

lista_arranques <- 1:I

lista_estimaciones <- lapply(lista_arranques, estim_sistematico)

df_estim <- data.frame(matrix(unlist(lista_estimaciones),ncol=1, byrow=TRUE ) )


colnames(df_estim) <- c("Estimacion")

EsperanzaE4   <-  mean(df_estim$Estimacion)
SesgoE4    <- Esperanza - parametro_poblacionalEst1
VarianzaE4 <-  var(df_estim$Estimacion)*(N-1)/N
DSE4       <- sqrt(Varianza)
CVestimsE4        <- 100*DS/parametro_poblacionalEst1


print(EsperanzaE4)
print(SesgoE4)
print(VarianzaE4)
print(DSE4)
print(CVestimsE4)


```
La esperanza, es decir, la estimación promedio de la población utilizando todas las muestras posible toma el mismo valor que el parametro poblacional, lo cual sugiere que el estimador es insesgado para esta estrategia. 
El sesgo, que es la diferencia entre la esperanza de la estimación y el valor verdadero, da cero, justo lo que se espera dado que el estimador es insesgado. El valor cero confirma que no hay desviación entre la media de las estimaciones y el valor poblacional.
La varianza es la medida de la dispersión de las estimaciones.
La desviación Estándar indica la variabilidad de las estimaciones alrededor de la media.
Finalmente el Coeficiente de Variación (CV) ayuda a comparar la precisión de la estimación en relación con el valor poblacional real, y el valor que toma (4,05) es bajo CV bajo (menor a 10%) por lo cual indica una buena precisión.

### Estrategia 2


```{r funciones Estrategia 2}

# Tamaño de la población y de la muestra
N <- nrow(Estrategia2E4)  # total de radios censales
n <- 240                   # tamaño de la muestra
I <- floor(N / n)          # intervalo de selección

# Valor verdadero del parámetro poblacional 
parametro_poblacionalEst2 <- sum(Estrategia2E4$Pob_radio)

# Definimos la función de estimación sistemática
estim_sistematico2 <- function(aa) {
  s = Estrategia2E4[seq(aa, N, I), ]
  estim2 <- I * sum(s$Pob_radio)
  return(c(estim2))
}

estimacionEst2 <- estim_sistematico2(2)

print(parametro_poblacionalEst2)
print(estimacionEst2)

```

```{r estimaciones posibles estrategia 2}

# Calculamos las I estimaciones posibles

lista_arranques2 <- 1:I

lista_estimaciones2 <- lapply(lista_arranques2, estim_sistematico2)

df_estim2 <- data.frame(matrix(unlist(lista_estimaciones2),ncol=1, byrow=TRUE ) )


colnames(df_estim2) <- c("Estimacion2")

EsperanzaE4.2   <-  mean(df_estim2$Estimacion2)
SesgoE4.2    <- Esperanza - parametro_poblacionalEst2
VarianzaE4.2 <-  var(df_estim2$Estimacion2)*(N-1)/N
DSE4.2       <- sqrt(Varianza)
CVestimsE4.2        <- 100*DS/parametro_poblacionalEst2


print(EsperanzaE4.2)
print(SesgoE4.2)
print(VarianzaE4.2)
print(DSE4.2)
print(CVestimsE4.2)


```

### Comparación de estrategias

```{r comparacion estrategias E4}

tabla_comparacionEstrategiasE4 <- data.frame(
  Estrategia = c("Estrategia 1", "Estrategia 2"),
  Esperanza = c(EsperanzaE4, EsperanzaE4.2),
  Sesgo = c(SesgoE4, SesgoE4.2),
  Varianza = c(VarianzaE4, VarianzaE4.2),
  Desviacion_Estandar = c(DSE4, DSE4.2),
  Coeficiente_Variacion = c(CVestimsE4, CVestimsE4.2)
)

# Mostrar la tabla de comparación
print(tabla_comparacion)
```

El sesgo es cero en ambas estrategias lo cual es un indicio de que ambas estrategias son estimadores insesgados del total poblacional.

La varianza de la Estrategia 2 es mayor que la de la Estrategia 1, lo que indica que el ordenamiento aleatorio puede introducir más variabilidad en las estimaciones.

El CV de ambas estrategias es igual, lo cual sugiere que las dos estrategias tienen un buen nivel de precisión.

La Estrategia 1, es decir ordenar por Provincia y Total de viviendas, presenta menos variabilidad, por lo cual podría ser la estrategia a elegir si queremos reducir la variabilidad en las estimaciones.


#EJERCICIO 5

Probaremos otra estrategia para estimar los parámetros del ejercicio anterior, seleccionando una muestra mediante Madow, con la cantidad de viviendas del radio como variable auxiliar, ordenando la tabla según código de radio (jurisdicción +
departamento + fracción + radio)

```{r creamos Tabla Ejercico 5}

#Creamos la tabla para el ejercicio 5. Eliminamos los radios sin viviendas o poblacion y lo ordenamos por codigo. 
radios_2010E5 <- radios_2010E4[radios_2010E4$Viv_radio>0,]
radios_2010E5 <- radios_2010E5[!is.na(radios_2010E5$Viv_radio),]
radios_2010 <- radios_2010[!is.na(radios_2010E5$Pob_radio),]
radios_2010E5 <- radios_2010E5[order(radios_2010E5$Codigo), ]

# N poblacional
N <- nrow(radios_2010)

# N poblacional
N <- nrow(radios_2010E5)

# Tamano de la muestra
n <- 240


# Definimos el vector de probabilidades de seleccion
radios_2010E5$pi_i <- n*radios_2010E5$Viv_radio/sum(radios_2010E5$Viv_radio)
max(radios_2010E5$pi_i)

# Ordenamos el marco de muestreo por codigo de radio
radios_2010E5 <-  radios_2010E5[order(radios_2010E5$Codigo),]


# Controlo que no haya pi_i mayores que 1, nulos ni missing
max(radios_2010E5$pi_i) 
min(radios_2010E5$pi_i)
sum( !is.finite(radios_2010E5$pi_i))


```

```{r verifico pi_i}

 summary(radios_2010E5$pi_i)
```


Seleccionamos mediante sampling, de la muestra de n=240 radios, mediante Madow, con total de viviendas del radio como variable auxiliar.

```{r Sampling E5}

# Seleccionamos la muestra y definimos el factor de expansion

# Probabilidades de seleccion

pikE5 <- radios_2010E5$pi_i

s=  sampling::UPsystematic(pikE5)


``` 


```{r Madow E5}

# Método de Madow con variable auxiliar Viv_radio.

estimo_madow <- function(n){
  radios_2010E5$pi_i <- n*radios_2010E5$Viv_radio/sum(radios_2010$Viv_radio)
  pikE5
  s = UPsystematic(pikE5,eps=1e-6)
  muestra_radiosE5 = radios_2010[s==1,]
  estimacionE5 <- sum(muestra_radiosE5$Viv_radio/muestra_radiosE5$pi_i)
  return(estimacionE5)
}

print(estimacionE5)

```


```{r Muestra E5}

summary(muestra_radiosE5)
nrow(muestra_radiosE5) 

``` 



```{r Survey E5}

#Configuramos el diseño de muestra para la estimación en survey

DesignE5 <- svydesign(id = ~1, data=muestra_radiosE5)
DesignE5

# Realizamos las estimaciones
survey_pobE5 <- svytotal(~Pob_radio, DesignE5)
survey_casaE5 <- svytotal(~Casa, DesignE5)
survey_rancho_casillaE5 <- svytotal(~Rancho_Casilla, DesignE5)

print(survey_pobE5)
print(survey_casaE5)
print(survey_rancho_casillaE5)



# survey asume ahora muestreo con reposicion

# Estimacion del total de poblacion
EstTotalPobE5 <- svytotal( ~Pob_radio , DesignE5, deff=TRUE, cv=TRUE, ci=TRUE)
EstTotalPobE5

100*cv(EstTotalPobE5)
survey::cv(EstTotal)

df_estim_total <- data.frame(EstTotal)
colnames(df_estim_total) <- c("Estimacion", "SE", "deff")

df_estim_total$CV <- 100*df_estim_total$SE/df_estim_total$Estimacion


# Estimacion del total de hogares que habitan Casa
EstTotalCasaE5 <- svytotal( ~Casa , DesignE5, deff=TRUE, cv=TRUE, ci=TRUE)
EstTotalCasaE5

100*cv(EstTotalCasaE5)
survey::cv(EstTotal)

df_estim_total <- data.frame(EstTotal)
colnames(df_estim_total) <- c("Estimacion", "SE", "deff")

df_estim_total$CV <- 100*df_estim_total$SE/df_estim_total$Estimacion




# Estimacion de la proporcion de hogares que habitan rancho casilla
EstRatioRancho_casillaE5 <- svyratio(~Rancho_casilla, DesignE5, deff=TRUE, cv=TRUE, ci=TRUE)
EstRatioRancho_casillaE5

100*cv(EstTotalRancho_casillaE5)
survey::cv(EstTotal)

df_estim_total <- data.frame(EstTotal)
colnames(df_estim_total) <- c("Estimacion", "SE", "deff")

df_estim_total$CV <- 100*df_estim_total$SE/df_estim_total$Estimacion





survey::cv(EstRatio)
deff <- deff(EstRatio)
deff

ICE5  <- confint(EstRatio)
ICE5

```


```{r Survey E5}

# Repetimos diez veces con un for

estimo <- function(x){
  s=  sampling::UPsystematic(pikE5)
  muestra_radiosE5 = radios_2010E5[s==1,]
  muestra_radiosE5$pondera <- 1/muestra_radiosE5$pi_i
  EstRatio <- svyratio(~Rancho_casilla, 
                       diseno, deff=TRUE, cv=TRUE, ci=TRUE)
  deff <- deff(EstRatio)
  cv   <- 100*survey::cv(EstRatio)
  
  caja <- c(EstRatio, deff, cv)
  return(caja)
}

lista_aaE5 <- 1:10

lista_estimacionesE5 <- lapply(lista_aaE5, estimo)

df_estimaciones <- data.frame(matrix(unlist(lista_estimaciones), 
                                     nrow=10, byrow=T))












df_estim_ratio <- data.frame(Estimacion = EstRatio[[1]],SE= sqrt(EstRatio[[2]])) 
df_estim_ratio$cv <- 100*df_estim_total$SE/df_estim_total$Estimacion
df_estim_ratio$deff <- deff 
colnames(df_estim_ratio) <- c("Estimacion", "SE", "cv", "deff")

```



NO LO PUEDO TERMINAR!! NO ME SALE LA MUESTRA


# EJERCICIO 6

## MAS

A partir de la encuesta realizada, el 53% de los electores (212 / 400) planean votar por el candidato X y la utilidad de esta información depende de los supuestos de MAS:

Independencia: Los electores son independientes entre sí, el voto de una persona no afecta el voto de otra.

Aleatoriedad: Los electores son seleccionadas de manera aleatoria en el universo, con la misma probabilidad de ser seleccionados.

Tamaño de la muestra: En este caso, desconocemos el N, pero 400 electores puede ser un buen numero. 

De acuerdo a esto, la utilidad de informacion que el estadístico puede brindar depende de si la muestra es representativa de la población. Dado que es una muestra aleatoria simple, y cada individuo tiene la misma probabilidad de ser seleccionado, como hemos mencionado, la muestra sería representativa.


## Coeficiente de Variación 

El coeficiente de variación (CV) es una medida que indica la precisión relativa de un estimador. Es la relación entre la desviación estándar del estimador y su valor esperado, multiplicada por 100.

```{r Coef Var E6}

n <- 400 
p_hat <- 212 / 400

# Desviación estándar de la proporción
sigma_hat <- sqrt((p_hat * (1 - p_hat)) / n)

# Coeficiente de variación (CV)
CVE6 <- (sigma_hat / p_hat) * 100

# Resultados
CVE6
```
Dado el tamaño de la muestra y la variabilidad de las respuestas, la estimación de la proporción de votantes de X tiene una variabilidad relativa del 4.71%. Un CV menor al 10% indica que el estimador es bastante preciso y que la proporción muestral obtenida es un buen estimador de la proporción verdadera en la población. 

## Conclusión 

El estadístico entonces informa que el 53% de los electores en la muestra votarán por X. Esta información es útil, ya que la muestra aleatoria simple es representativa, bajo los supuestos de independencia y aleatoriedad.

El CV del estimador indica que proporción estimada de 53% tiene una variabilidad del 4.71%, indicando que es bastante precisa. 



# EJERCICIO 7

El candidato quiere saber el tamaño de muestra necesario para estimar el porcentaje de votos con un intervalo de confianza del 95% y una amplitud total de 1%. 

Supone que obtendrá un porcentaje cercano al 50%.  

La formula para obtener el tamaño de muestra para un intervalo es

n = [ Z2 * p * (1−p)  ] / E2

```{r Tamano muestra E7}


Z <- 1.96  # Valor crítico para un intervalo de confianza del 95%
p <- 0.5   # Proporción esperada de votos
E <- 0.01  # Amplitud del intervalo de confianza (1%)

# Calculo
n <- (Z^2 * p * (1 - p)) / E^2


print(n)

```


Para garantizar que el intervalo de confianza tenga una amplitud total de 1% con un nivel de confianza del 95%, se necesitaría una muestra de 9,604 electores.


# EJERCICIO 8 

